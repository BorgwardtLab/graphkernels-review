#!/usr/bin/env python3
#
# visualise_kernel_accuracies.py: visualises the individual kernels by
# means of their accuracies on the individual data sets. Multiple plot
# variants will be provided by this script (based on different metrics
# or dissimilarity measures).

import argparse

from sklearn.manifold import MDS
from sklearn.manifold import TSNE

from scipy.spatial.distance import pdist
from scipy.spatial.distance import squareform

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


def embed_distance_matrix(D):
    '''
    Embeds a distance matrix into 2D space for visualisation and
    subsequent analysis.

    :param D: Distance matrix

    :return: Coordinate matrix. Indexing follows the indexing of
    the original matrix; no reshuffling is done.
    '''

    embedding = MDS(
        metric=True,
        dissimilarity='precomputed',
        random_state=42
    )

    return embedding.fit_transform(D)


def resample_data_frame(df, n_samples):
    '''
    Given a data frame whose cells contain a mean and a standard
    deviation, performs `n_samples` sampling operations, storing
    the resulting matrices in a list.
    '''

    def sample(x):
        '''
        Takes a cell of the data frame, converts it into the
        corresponding representation of mean/sdev, and draws
        a random sample from the corresponding distribution.
        '''

        # Short-circuit sampling procedure if there's nothing to sample
        if type(x) != str and np.isnan(x):
            return 0.0

        mean, _, sdev = str(x).split()

        mean = float(mean)
        sdev = float(sdev)

        return mean

    matrices = []

    for i in range(n_samples):
        df_ = df.iloc[:, 1:].applymap(sample)
        matrices.append(df_.iloc[:, 1:].to_numpy())

    return matrices


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('INPUT', type=str, help='Input file')

    args = parser.parse_args()

    df = pd.read_csv(args.INPUT)

    # Check whether we have to perform *sampling* because the cells of
    # the data frame are mean accuracies with standard deviations.
    if 'object' in df.iloc[:, 1:].dtypes.values:
        # TODO: make configurable
        n_samples = 100
        feature_matrices = resample_data_frame(df, n_samples)
    else:
        feature_matrices = [df.iloc[:, 1:].to_numpy()]

    kernel_names = df.iloc[:, 0].values
    data_set_names = df.iloc[0, :].values   # these are not required...

    metrics = [
        {'metric': 'minkowski', 'p': 1},  # $L_1$
        {'metric': 'minkowski', 'p': 2},  # $L_2$
        {'metric': 'chebyshev'},
        {'metric': 'cityblock'}
    ]

    fig, axes = plt.subplots(
        figsize=(16, 4),
        ncols=len(metrics),
        nrows=1,
        squeeze=True
    )

    for index, kwargs in enumerate(metrics):

        # Will contain all coordinate matrices generated by the current
        # embedding method. This makes it possible to calculate a mean,
        # as well as a standard deviation for *positions*.
        coordinate_matrices = []
    
        for X in feature_matrices:
            D = squareform(pdist(X, **kwargs))
            Y = embed_distance_matrix(D)

            coordinate_matrices.append(Y)

        Y = np.mean(coordinate_matrices, axis=0)
        s = np.std(coordinate_matrices, axis=0)

        # Prepare plots (this is just for show; we are actually more
        # interested in the output files).
        title = kwargs['metric']

        if 'p' in kwargs:
            title += '_' + str(kwargs['p'])

        axes[index].set_aspect('equal')
        axes[index].scatter(Y[:, 0], Y[:, 1])
        axes[index].set_title(title)
        axes[index].tick_params(
            bottom=False, top=False,
            left=False, right=False,
            labelbottom=False, labeltop=False,
            labelleft=False, labelright=False,
        )

        for j, text in enumerate(kernel_names):
            x = Y[j, 0]
            y = Y[j, 1]
            axes[index].annotate(text, (x, y))


    plt.tight_layout()
    plt.show()
